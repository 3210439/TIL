# Java NIO 이해하기: 버퍼, 채널, 셀렉터

Java NIO(New Input/Output)는 입출력 작업을 비동기적이고 효율적으로 처리하기 위한 강력한 API입니다. 기존 Java IO는 스트림과 멀티스레딩에 의존하여 다수의 클라이언트를 처리했지만, NIO는 버퍼, 채널, 셀렉터를 활용해 성능과 확장성을 최적화합니다. 이 글에서는 Java NIO의 핵심 구성 요소인 다이렉트/논다이렉트 버퍼, 채널, 셀렉터의 역할을 정리합니다.

## 다이렉트 버퍼 vs 논다이렉트 버퍼

NIO의 버퍼는 채널에서 데이터를 읽거나 쓰기 위해 사용됩니다. 버퍼는 **다이렉트 버퍼**와 **논다이렉트 버퍼**로 나뉘며, 각각의 특징은 다음과 같습니다:

### 버퍼의 특징
- **버퍼 생성 속도**:
  - **논다이렉트 버퍼**: JVM의 힙 메모리에 할당되므로 생성 속도가 빠릅니다.
  - **다이렉트 버퍼**: 운영체제의 네이티브 메모리에 할당되므로 생성 속도가 느립니다.
  
- **입출력 성능**:
  - **논다이렉트 버퍼**: JVM 힙과 네이티브 메모리 간 데이터 복사로 인해 입출력 성능이 낮습니다.
  - **다이렉트 버퍼**: 네이티브 메모리에 직접 접근하므로 입출력 성능이 더 뛰어납니다.

- **메모리 종류**:
  - **논다이렉트 버퍼**: JVM의 힙 메모리에 저장되며, 가비지 컬렉터에 의해 관리됩니다.
  - **다이렉트 버퍼**: 운영체제의 네이티브 메모리에 할당되어 JVM 힙 관리를 우회합니다.

**활용 사례**: 다이렉트 버퍼는 네트워크나 파일 입출력과 같은 고성능 작업에 적합하며, 논다이렉트 버퍼는 입출력 부하가 적고 빠른 메모리 할당이 필요한 경우에 유용합니다.

## NIO의 채널

기존 IO는 단방향 스트림(읽기 또는 쓰기 중 하나)을 사용하지만, NIO의 **채널**은 양방향으로 읽기와 쓰기를 모두 지원합니다. 채널은 항상 버퍼와 함께 사용되며, 데이터를 버퍼에 저장하거나 버퍼에서 읽어옵니다.

### 채널을 사용하는 이유
- **양방향성**: 읽기와 쓰기를 동시에 지원하여 기존 IO 스트림보다 유연합니다.
- **비동기 처리**: 비동기 모드를 지원해 단일 스레드로 다수의 클라이언트를 효율적으로 처리할 수 있습니다.
- **효율성**: 버퍼와 함께 작동하여 데이터 복사를 최소화하고 입출력 효율성을 높입니다.

### 주요 채널 유형
- **ServerSocketChannel**: 서버에서 클라이언트 연결 요청을 수신하는 데 사용됩니다. 비동기 모드로 설정해 다수의 클라이언트 연결을 효율적으로 처리하며, 셀렉터와 함께 사용됩니다.
- **SocketChannel**: 클라이언트와 서버 간의 단일 연결을 관리하며 데이터를 읽고 쓰는 데 사용됩니다. 비동기 모드를 지원해 높은 동시성을 제공합니다.

## 셀렉터(Selector)의 역할

**셀렉터**는 단일 스레드로 다수의 채널을 관리할 수 있게 해주는 NIO의 핵심 구성 요소입니다. 셀렉터는 채널의 특정 이벤트(예: 연결 요청, 데이터 읽기 준비, 데이터 쓰기 준비)를 모니터링하고, 이벤트 발생 시 애플리케이션에 알립니다.

### 셀렉터를 사용하는 이유
- **멀티플렉싱**: 단일 스레드로 다수의 채널을 관리하여 기존 IO의 스레드당 클라이언트 처리 방식을 대체합니다. 이는 수천 개의 동시 연결을 처리하는 서버에 적합합니다.
- **비동기 입출력**: 비동기 모드의 채널과 함께 작동하여 준비된 채널만 처리하므로 리소스 사용을 최적화합니다.
- **효율성**: 셀렉터는 준비된 채널만 선택적으로 처리해 성능을 향상시킵니다.

### 셀렉터 동작 방식
1. **ServerSocketChannel**을 셀렉터에 등록하여 연결 요청(OP_ACCEPT)을 감시합니다.
2. 클라이언트 연결이 발생하면 셀렉터가 이를 감지하고, 애플리케이션은 연결을 수락해 **SocketChannel**을 생성합니다.
3. **SocketChannel**을 셀렉터에 등록하여 읽기(OP_READ) 또는 쓰기(OP_WRITE)를 감시합니다.
4. 셀렉터는 등록된 모든 채널을 지속적으로 모니터링하며 준비된 채널을 애플리케이션에 알립니다.

## ServerSocketChannel과 SocketChannel의 역할

- **ServerSocketChannel**:
  - **목적**: 서버에서 클라이언트의 연결 요청을 수신합니다.
  - **비동기 지원**: 비동기 모드로 다수의 연결 요청을 단일 스레드로 처리할 수 있습니다.
  - **활용 사례**: 확장 가능한 서버 구축에 필수적이며, 다수의 클라이언트 연결을 효율적으로 관리합니다.

- **SocketChannel**:
  - **목적**: 클라이언트와 서버 간의 단일 연결에서 데이터 읽기와 쓰기를 처리합니다.
  - **비동기 지원**: 비동기 모드로 동작하여 스레드를 블록하지 않고 입출력을 처리합니다.
  - **활용 사례**: TCP 연결을 통한 클라이언트-서버 통신에 사용됩니다.

## 기존 IO vs NIO

**기존 Java IO**:
- 클라이언트당 전용 스레드가 필요하여 다수의 클라이언트를 처리할 때 리소스 소모가 큽니다.
- 스트림은 단방향(읽기 또는 쓰기)만 지원합니다.

**Java NIO**:
- 채널과 셀렉터를 활용해 단일 스레드로 다수의 클라이언트를 처리하여 확장성을 높입니다.
- 양방향 채널을 지원하여 읽기와 쓰기를 동시에 처리할 수 있습니다.
- 다이렉트 버퍼를 통해 입출력 성능을 최적화합니다.

## 결론

Java NIO는 **다이렉트/논다이렉트 버퍼**, **양방향 채널**, **셀렉터**를 통해 고성능, 확장 가능한 애플리케이션 개발을 가능하게 합니다. **ServerSocketChannel**과 **SocketChannel**을 셀렉터와 함께 사용하면 다수의 클라이언트를 효율적으로 관리할 수 있습니다. NIO의 이러한 특징을 이해하고 활용하면 네트워크 프로그래밍에서 높은 성능과 확장성을 달성할 수 있습니다.

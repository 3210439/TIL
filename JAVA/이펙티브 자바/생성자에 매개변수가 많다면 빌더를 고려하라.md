# 아이템 2: 생성자에 매개변수가 많다면 빌더 패턴을 고려하라

## 배경
객체 생성 시 매개변수가 많아지면 코드를 작성하거나 읽기 어려워지는 문제가 발생할 수 있습니다. 이를 해결하기 위해 다양한 패턴이 존재하며, 대표적으로 **점층적 생성자 패턴**, **자바빈즈 패턴**, 그리고 **빌더 패턴**이 있습니다. 이 문서에서는 각 패턴의 특징과 빌더 패턴의 장점을 중심으로 설명합니다.

## 1. 점층적 생성자 패턴 (Telescoping Constructor Pattern)
점층적 생성자 패턴은 여러 개의 생성자를 정의해 매개변수의 조합을 처리하는 방식입니다. 예를 들어, 필수 매개변수만 받는 생성자부터 선택적 매개변수를 하나씩 추가한 생성자를 정의합니다.

### 단점
- **가독성 저하**: 매개변수 개수가 많아질수록 생성자 호출 코드가 복잡해지고, 어떤 매개변수가 어떤 값을 의미하는지 파악하기 어렵습니다.
- **유연성 부족**: 매개변수 조합이 많아질수록 생성자 개수가 기하급수적으로 증가합니다.
- **실수 가능성**: 클라이언트 코드에서 잘못된 순서로 매개변수를 전달할 위험이 있습니다.

### 예시
```java
public class Product {
    private final String name; // 필수
    private final int price;   // 필수
    private final String brand; // 선택
    private final int stock;   // 선택

    public Product(String name, int price) {
        this(name, price, null, 0);
    }

    public Product(String name, int price, String brand) {
        this(name, price, brand, 0);
    }

    public Product(String name, int price, String brand, int stock) {
        this.name = name;
        this.price = price;
        this.brand = brand;
        this.stock = stock;
    }
}
```

## 2. 자바빈즈 패턴 (JavaBeans Pattern)
자바빈즈 패턴은 매개변수가 없는 기본 생성자로 객체를 생성한 뒤, 세터(setter) 메서드를 호출해 필요한 매개변수 값을 설정하는 방식입니다.

### 장점
- **가독성**: 각 속성을 명시적으로 설정하므로 코드가 직관적입니다.
- **유연성**: 원하는 속성만 설정할 수 있습니다.

### 단점
- **일관성 문제**: 객체가 완전히 초기화되기 전까지 일관성(consistency)이 깨진 상태로 존재할 수 있습니다.
- **불변성 불가**: 세터 메서드 때문에 객체를 불변(immutable)으로 만들 수 없습니다.
- **멀티스레드 환경 취약**: 객체 생성 과정에서 여러 스레드가 접근하면 예상치 못한 동작이 발생할 수 있습니다.
- **장황한 코드**: 여러 세터 메서드를 호출해야 하므로 코드가 길어질 수 있습니다.

### 예시
```java
public class Product {
    private String name;
    private int price;
    private String brand;
    private int stock;

    public Product() {}

    public void setName(String name) { this.name = name; }
    public void setPrice(int price) { this.price = price; }
    public void setBrand(String brand) { this.brand = brand; }
    public void setStock(int stock) { this.stock = stock; }
}
```

### 사용 예시
```java
Product product = new Product();
product.setName("Laptop");
product.setPrice(1000);
product.setBrand("BrandX");
product.setStock(50);
```

## 3. 빌더 패턴 (Builder Pattern)
빌더 패턴은 점층적 생성자 패턴과 자바빈즈 패턴의 단점을 보완한 객체 생성 방식입니다. **빌더 객체**를 사용해 필수 및 선택적 매개변수를 단계적으로 설정한 뒤, 최종적으로 객체를 생성합니다.

### 장점
- **가독성**: 메서드 체이닝(method chaining)을 통해 직관적이고 읽기 쉬운 코드를 작성할 수 있습니다.
- **불변성**: 빌더를 통해 생성된 객체는 불변(immutable)으로 만들 수 있습니다.
- **유연성**: 선택적 매개변수를 유연하게 처리하며, 가변인수(varargs)와 같은 기능을 쉽게 구현할 수 있습니다.
- **일관성 보장**: 객체는 완전히 초기화된 상태로 생성되므로 일관성이 유지됩니다.
- **계층적 클래스에 적합**: 추상 클래스나 인터페이스와 함께 사용하면 하위 클래스에서 빌더를 재사용하거나 확장하기 쉽습니다.

### 단점
- **구현 복잡성**: 빌더 클래스를 별도로 작성해야 하므로 초기 코드량이 증가합니다.
- **메모리 사용**: 빌더 객체를 생성하므로 약간의 오버헤드가 발생할 수 있습니다.

### 예시
```java
public class Product {
    private final String name;
    private final int price;
    private final String brand;
    private final int stock;

    private Product(Builder builder) {
        this.name = builder.name;
        this.price = builder.price;
        this.brand = builder.brand;
        this.stock = builder.stock;
    }

    public static class Builder {
        // 필수 매개변수
        private final String name;
        private final int price;
        // 선택적 매개변수
        private String brand = null;
        private int stock = 0;

        public Builder(String name, int price) {
            this.name = name;
            this.price = price;
        }

        public Builder brand(String brand) {
            this.brand = brand;
            return this;
        }

        public Builder stock(int stock) {
            this.stock = stock;
            return this;
        }

        public Product build() {
            return new Product(this);
        }
    }

    // Getter 메서드 (생략 가능)
    public String getName() { return name; }
    public int getPrice() { return price; }
    public String getBrand() { return brand; }
    public int getStock() { return stock; }
}
```

### 사용 예시
```java
Product product = new Product.Builder("Laptop", 1000)
                        .brand("BrandX")
                        .stock(50)
                        .build();
```

## 4. 빌더 패턴의 추가 활용
### 가변인수 매개변수
빌더 패턴은 가변인수(varargs)를 활용해 여러 값을 유연하게 처리할 수 있습니다. 예를 들어, 제품의 태그 목록을 추가하려면 다음과 같이 구현할 수 있습니다.

```java
public class Product {
    private final String name;
    private final int price;
    private final List<String> tags;

    private Product(Builder builder) {
        this.name = builder.name;
        this.price = builder.price;
        this.tags = builder.tags;
    }

    public static class Builder {
        private final String name;
        private final int price;
        private List<String> tags = new ArrayList<>();

        public Builder(String name, int price) {
            this.name = name;
            this.price = price;
        }

        public Builder addTags(String... tags) {
            this.tags.addAll(Arrays.asList(tags));
            return this;
        }

        public Product build() {
            return new Product(this);
        }
    }
}
```

### 계층적 클래스와의 사용
빌더 패턴은 계층적으로 설계된 클래스(예: 추상 클래스나 인터페이스)와 함께 사용할 때 특히 유용합니다. 각 하위 클래스는 자신의 빌더를 정의해 고유한 속성을 설정할 수 있습니다.

```java
public abstract class Product {
    protected final String name;

    protected Product(Builder<?> builder) {
        this.name = builder.name;
    }

    public static abstract class Builder<T extends Builder<T>> {
        protected String name;

        @SuppressWarnings("unchecked")
        public T name(String name) {
            this.name = name;
            return (T) this;
        }

        public abstract Product build();
    }
}

public class ConcreteProduct extends Product {
    private final int price;

    private ConcreteProduct(Builder builder) {
        super(builder);
        this.price = builder.price;
    }

    public static class Builder extends Product.Builder<Builder> {
        private int price;

        public Builder price(int price) {
            this.price = price;
            return this;
        }

        @Override
        public ConcreteProduct build() {
            return new ConcreteProduct(this);
        }
    }
}
```

### 사용 예시
```java
ConcreteProduct product = new ConcreteProduct.Builder()
                            .name("Laptop")
                            .price(1000)
                            .build();
```

## 5. 빌더 패턴 vs 다른 패턴
| **특징**                  | **점층적 생성자** | **자바빈즈 패턴** | **빌더 패턴** |
|---------------------------|------------------|------------------|--------------|
| **가독성**                | 낮음             | 중간             | 높음         |
| **불변성 지원**           | 가능             | 불가능           | 가능         |
| **일관성**                | 높음             | 낮음             | 높음         |
| **유연성**                | 낮음             | 높음             | 높음         |
| **멀티스레드 안전성**     | 안전             | 취약             | 안전         |
| **코드 복잡도**           | 낮음             | 중간             | 높음         |

## 6. 주의사항
- **필수 매개변수와 선택적 매개변수 구분**: 빌더 생성자에서 필수 매개변수를 명시적으로 요구하도록 설계하세요.
- **유효성 검증**: `build()` 메서드에서 객체 생성 전에 매개변수의 유효성을 검사해 예외를 던지는 것이 좋습니다.
  ```java
  public Product build() {
      if (price < 0) {
          throw new IllegalArgumentException("Price cannot be negative");
      }
      return new Product(this);
  }
  ```
- **성능 고려**: 빌더 객체 생성과 메서드 체이닝은 약간의 오버헤드를 유발할 수 있으므로, 성능이 중요한 경우 사용 여부를 신중히 검토하세요.

## 핵심 정리
- 생성자나 정적 팩터리에 매개변수가 많을 경우, **빌더 패턴**은 가독성, 유연성, 불변성, 일관성을 모두 만족하는 훌륭한 선택입니다.
- 점층적 생성자 패턴은 간단한 경우에 적합하지만, 매개변수가 많아질수록 복잡해집니다.
- 자바빈즈 패턴은 유연하지만 불변성을 보장할 수 없고, 객체 생성 과정에서 일관성이 깨질 위험이 있습니다.
- 빌더 패턴은 특히 계층적 클래스 구조에서 강력하며, 가변인수나 복잡한 객체 생성 로직을 처리할 때 유용합니다.
- 빌더 패턴을 사용할 때는 필수 매개변수와 선택적 매개변수를 명확히 구분하고, 유효성 검증을 철저히 수행하세요.

# 😶‍🌫️17장 냄새와 휴리스틱

## 주석

C1: 부적절한 정보

- 주석은 메타 정보만 주석으로 넣는다.

C2: 쓸모 없는 주석

- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 쓸모없다.

C3: 중복된 주석

- 코드만으로 충분한데 추가된 중복된 주석

C4: 성의 없는 주석

- 주석을 사용할 것이면 최대한 시간을 들여 멋지게 작성한다.

C5: 주석 처리된 코드

- 얼마나 오래되었는지, 지워선 안되는 중요한 코드인지 알 수 없다.
- 소스 코드 관리 시스템이 기억하기 때문에 지워도 된다.

## 환경

E1: 여러 단계로 빌드해야 한다.

- 한 명령어로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

E2: 여러 단계로 테스트 해야 한다.

- 모든 단위 테스트는 한 명령어로 돌려야 한다.

## 함수

F1: 너무 많은 인수

- 인수 넷 이상은 최대한 피하자

F2: 출력 인수

- 출력 인수는 직관을 정면으로 위배한다.

F3: 플래그 인수

- 플래그 인수는 혼란을 줄 수 있기 때문에 가능한 피해야 한다.

F4: 죽은 함수

- 호출하지 않는 함수는 정리한다.

## 일반

G1: 한 소스 파일에 여러 언어를 사용한다.

- 소스 파일에서 언어 수와 범위를 최대한 줄여야한다.

G2: 당연한 동작을 구현하지 않는다.

- 코드가 코드 명에 해당되는 기능을 수행하지 않는다면, 읽는 사람은 코드를 신뢰할 수 없어 일일이 코드를 확인해야하는 수고로움을 겪게 된다.

G3: 경계를 올바로 처리하지 않는다.

- 가능한 모든 경계 조건을 찾아내고, 모든 경제 조건을 테스트하는 테스트 케이스를 작성하라

G4: 안전 절차 무시

- 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.

G5: 중복

- 코드에서 중복을 발견하면 추상화의 기회로 생각하자
- 여러 모듈에서 일련의 switch/case나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복은 다형성 polymorphism으로 대체해야 한다.
- 중복은 중복이므로 TEMPLATE METHOD패턴이나 STRATEGY 패턴으로 중복을 제거한다.

G6: 추상화 수준이 올바르지 못하다.

- 추상화는 철저하게
- 모든 저차원 개념은 파생 클래스에 넣는다.
- 모든 고차원 개념은 기초 클래스에 넣는다.
- 고차원과 저차원 개념을 섞으면 안된다.

G7: 기초 클래스가 파생 클래스에 의존한다.

- 독립성을 보장하기위해 분리한다.
- 기초 클래스는 파생 클래스를 몰라야 한다.

G8: 과도한 정보

- 잘 정의된 모듈은 인터페이스가 아주 적다.
- 잘 정의된 인터페이스 → 결합도(coupling) 낮음

G9: 죽은 코드

- 사용되지 않는 코드를 죽은 코드라고 한다.
- 죽은 코드는 다른 코드들이 변해도 변하지 않기 때문에 시간이 지날 수록 알아보기 힘들어진다.

G10: 수직 분리

- 변수와 함수는 사용되는 위치에 가깝게 정의한다.
- 비공개 함수는 처음으로 호출한 직후에 정의한다.

G11: 일관성 부족

- 유사한 개념은 같은 방식으로 구현한다.
- 최소 놀람의 원칙 `The Principle of Least Surprise'에도 부합한다.
- 일관성이 좋으면 유지보수하기 좋다.

G12: 잡동사니

- 사용하지 않는 변수, 함수, 주석은 제거하자

G13: 인위적 결합

- 무관한 개념을 결합하지 말자

G14: 기능 욕심

- 클래스 메서드는 다른 클래스의 변수와 함수에 관심을 가져선 안된다.

G15: 선택자 인수

- 선택자 인수는 목적을 기억하기 힘들고 여러 함수를 하나로 조합한다.

G16: 모호한 의도

- 코드를 짤 때는 의도를 최대한 분명히 밝힌다.
- 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다.

# 🫠17장 냄새와 휴리스틱

## 주석

C1: 부적절한 정보

- 주석은 메타 정보만 주석으로 넣는다.

C2: 쓸모 없는 주석

- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 쓸모없다.

C3: 중복된 주석

- 코드만으로 충분한데 추가된 중복된 주석

C4: 성의 없는 주석

- 주석을 사용할 것이면 최대한 시간을 들여 멋지게 작성한다.

C5: 주석 처리된 코드

- 얼마나 오래되었는지, 지워선 안되는 중요한 코드인지 알 수 없다.
- 소스 코드 관리 시스템이 기억하기 때문에 지워도 된다.

## 환경

E1: 여러 단계로 빌드해야 한다.

- 한 명령어로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

E2: 여러 단계로 테스트 해야 한다.

- 모든 단위 테스트는 한 명령어로 돌려야 한다.

## 함수

F1: 너무 많은 인수

- 인수 넷 이상은 최대한 피하자

F2: 출력 인수

- 출력 인수는 직관을 정면으로 위배한다.

F3: 플래그 인수

- 플래그 인수는 혼란을 줄 수 있기 때문에 가능한 피해야 한다.

F4: 죽은 함수

- 호출하지 않는 함수는 정리한다.

## 일반

G1: 한 소스 파일에 여러 언어를 사용한다.

- 소스 파일에서 언어 수와 범위를 최대한 줄여야한다.

G2: 당연한 동작을 구현하지 않는다.

- 코드가 코드 명에 해당되는 기능을 수행하지 않는다면, 읽는 사람은 코드를 신뢰할 수 없어 일일이 코드를 확인해야하는 수고로움을 겪게 된다.

G3: 경계를 올바로 처리하지 않는다.

- 가능한 모든 경계 조건을 찾아내고, 모든 경제 조건을 테스트하는 테스트 케이스를 작성하라

G4: 안전 절차 무시

- 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.

G5: 중복

- 코드에서 중복을 발견하면 추상화의 기회로 생각하자
- 여러 모듈에서 일련의 switch/case나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복은 다형성 polymorphism으로 대체해야 한다.
- 중복은 중복이므로 TEMPLATE METHOD패턴이나 STRATEGY 패턴으로 중복을 제거한다.

G6: 추상화 수준이 올바르지 못하다.

- 추상화는 철저하게
- 모든 저차원 개념은 파생 클래스에 넣는다.
- 모든 고차원 개념은 기초 클래스에 넣는다.
- 고차원과 저차원 개념을 섞으면 안된다.

G7: 기초 클래스가 파생 클래스에 의존한다.

- 독립성을 보장하기위해 분리한다.
- 기초 클래스는 파생 클래스를 몰라야 한다.

G8: 과도한 정보

- 잘 정의된 모듈은 인터페이스가 아주 적다.
- 잘 정의된 인터페이스 → 결합도(coupling) 낮음

G9: 죽은 코드

- 사용되지 않는 코드를 죽은 코드라고 한다.
- 죽은 코드는 다른 코드들이 변해도 변하지 않기 때문에 시간이 지날 수록 알아보기 힘들어진다.

G10: 수직 분리

- 변수와 함수는 사용되는 위치에 가깝게 정의한다.
- 비공개 함수는 처음으로 호출한 직후에 정의한다.

G11: 일관성 부족

- 유사한 개념은 같은 방식으로 구현한다.
- 최소 놀람의 원칙 `The Principle of Least Surprise'에도 부합한다.
- 일관성이 좋으면 유지보수하기 좋다.

G12: 잡동사니

- 사용하지 않는 변수, 함수, 주석은 제거하자

G13: 인위적 결합

- 무관한 개념을 결합하지 말자

G14: 기능 욕심

- 클래스 메서드는 다른 클래스의 변수와 함수에 관심을 가져선 안된다.

G15: 선택자 인수

- 선택자 인수는 목적을 기억하기 힘들고 여러 함수를 하나로 조합한다.

G16: 모호한 의도

- 코드를 짤 때는 의도를 최대한 분명히 밝힌다.
- 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다.

G17: 잘못 지운 책임

- 코드 배치 위치는 중요 → 최소 놀람의 원칙 적용

G18: 부적절한 static 함수

- static 함수보다 인스턴스 함수가 더 좋다.
- 의심스럽다면 인스턴스 함수로 정의한다.

G19: 서술적 변수

- 서술적인 변수 이름은 많이 써도 괜찮다.
- 서술적 변수는 모듈을 일기 쉬운 모듈로 만들어준다.

G20: 이름과 기능이 일치하는 함수

- 이름만으로 분명치 않고 구현을 살피거나 문서를 봐야한다면 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

G21: 알고리즘을 이해하라

- 괴상한 대부분의 코드는 알고리즘을 이해하지 못한 상태로 구현한 코드이다.
- 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.

G22: 논리적 의존성은 물리적으로 드러내라

- 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다.
- 의존하는 정보는 명시적으로 요청하라

G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

- 선택 유형 하나에는 switch 문을 한번만 사용하라

G24: 표준 표기법을 따르라

- 모두가 동의한 위치에 넣는다는 사실이 중요하다.

G25: 매직 숫자는 명명된 상수로 교체하라

- 숫자가 자명하다면 상수로 교체할 필요는 없다.
- 매직 숫자는 단지 숫자만을 의미하진 않는다.

G26: 정확하라

- 코드에서 모호성과 부정확은 의견차나 게으름의 결과이다.. 어느쪽이든 제거해야 마땅하다.

G27: 관례보다 구조를 사용하라

- 구조 자체로 강제하면 더 좋다.
- 예로 enum은 switch/case문 보다 더 좋다.

G28: 조건을 캡슐화하라

- 부울 논리는 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.

G29: 부정 조건은 피하라

- 부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하면 긍정 조건으로 표현하라.

G30: 함수는 한 가지만 해야 한다.

G31: 숨겨진 시각적인 결합

- 순차적으로 수행되야되는 함수이지만 숨겨져있을 경우 코드를 보는 다른 프로그래머는 해당 코드를 수정할 때 이유 모를 에러를 만나게 될 수 있다.

G32: 일관성을 유지하라

- 구조에 일관성이 없어 보인다면 남들이 맘대로 바꿔도 괜찮다고 생각한다.
- 일관성이 있으면 남들도 일관적으로 코드를 짜게 된다.

G33: 경계 조건을 캡슐화하라

G34: 함수는 추상화 수준을 한 단계만 내려가야 한다.

- 함수 내 모든 문장은 추상화 수준이 동일해야 한다.

G35: 설정 정보는 최상위 단계에 둬라

- 설정 관련 상수는 최상위 단계에 둔다. 그래야 변경하기도 쉽다.
- 설정 관련 변수는 나머지 코드에 인수로 넘긴다. 저차원 함수에 상수 값을 정의하면 안된다.

G36: 추이적 탐색을 피하라

- 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다.
- A가 B를 사용하고 B가 C를 사용한다 하더라도 A가 C를 알아야 할 필요는 없다.
    - 예를 들어 a.getB().getC().doSomething();은 바람직하지 않다.
    - 이를 디미터 법칙이라 부른다.


## 자바

J1: 긴 import 목록을 피하고 와일드카드를 사용하라

- 와일드 카드 → import package.*;
- 와일드 카드 import 문은 때로 이름 충돌이나 모호성을 초래한다. 다소 번거롭지만 자주 발생하지 않으므로 여전히 와일드카드 import 문이 명시적인 import 문보다 좋다.

J2: 상수는 상속하지 않는다.

J3: 상수 대 Enum

## 이름

N1: 서술적인 이름을 사용하라.

- 이름은 신중하게 고른다.
- 소프트웨어 가독성 90%는 이름이 결정한다.

N2: 적절한 추상화 수준에서 이름을 선택하라

N3: 가능하다면 표준 명명법을 사용하라

N4: 명확한 이름

- 이름이 길어져도 명확한 이름이 좋다.

N5: 긴 범위는 긴 이름을 사용하라

- 이름 길이는 범위 길이에 비례해야 한다.

N6: 인코딩을 피하라

- 이름에 유형 과 범위 정보를 포함하지 마라

N7: 이름으로 부수 효과를 설명하라

```jsx
public ObjectOutputStream getOos() throws IOException {
	if (m_oos == null) {
		m_oos = new ObjectOutputStream(m_socket.getOutput(Stream());
	}
	return m_oos;
}
```

위 함수는 단순히 “oos”만 가져오지 않는다. 기존에 “oos”가 없으면 생성한다. 그러므로 createOrReturnOos라는 이름이 더 좋다.

이 글을 보면서 나도 유저가 포인트 정보를 가져올 때 정보가 없으면 새로 생성해서 가져오고 있으면 가져오는 기능을 getPoint라고 구현한 적이 있음을 떠올렸다. 매우 유익한 정보인 것 같다고 느낀다.

## 테스트

T1: 불충분한 테스트

- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.

T2: 커버리지 도구를 사용하라!

T3: 사소한 테스트를 건너뛰지 마라

- 사소한 테스트는 짜기 쉬우며 구현에 드는 비용을 넘어선다.

T4: 무시한 테스트는 모호함을 뜻한다.

T5: 경계 조건을 테스트하라

T6: 버그 주변은 철저히 테스트하라

T7: 실패 패턴을 살펴라

T8: 테스트 커버리지 패턴을 살펴라

T9: 테스트는 빨라야 한다

- 느린 테스트 케이스는 실행하지 않게 된다. 일정이 촉박하면 느린 테스트 케이스를 제일 먼저 건너뛴다. 그러므로 테스트 케이스가 빨리 돌아가게 최대한 노력한다.
